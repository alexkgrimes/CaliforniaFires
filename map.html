<html>
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  .state {
    fill: #ccc;
    stroke: #fff;
  }

  .symbol {
    fill-opacity: .5;
    stroke: #fff;
  }
</style>

<body>
  <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
  <!-- d3 v6 integration -->
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <!-- d3 topojson -->
  <script src="http://d3js.org/topojson.v1.min.js"></script>

  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
  <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
  <script>
    let width = 960, height = 700;

    let projection = d3.geoMercator()
      .translate([width / 0.16, height / 0.31])  
      .scale([2700]);

    let projectionWrapper = arr => {
      let proj = projection(arr);
      if (isNaN(proj[0]) || isNaN(proj[1])) {
        return [-1, -1];
      } else {
        return proj;
      }
    };
    
    let path = d3.geoPath()
      .projection(projection);

    const zoom = d3.zoom()
      .on('zoom', (event) => {
        mapLayer.attr('transform', event.transform);
      })
      .scaleExtent([1, 40]);

    let mapLayer = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height)
      .call(zoom)
      .append("g");

    let dataset, california, fires, minAcres, maxAcres;
    let attributes = ["incident_acres_burned"];

    ready();

    async function ready() {
      california = await d3.json("california.geojson");
      fires = await d3.csv("mapdataall.csv");
      fires.forEach( d => {
        d.incident_acres_burned = +d.incident_acres_burned;
        if (d.incident_acres_burned == 0) {
          d.incident_acres_burned = 1;
        }
      });
      dataset = fires;

      ranges = {};
      filter_query = [];
      for (let attr of attributes) {
        let column = dataset.map(d => d[attr]);
        ranges[attr] = [
          d3.min(column),
          d3.max(column)
        ]
        filter_query.push({
          key: attr,
          range: [ // deep copy
            ranges[attr][0],
            ranges[attr][1]
          ]
        })
      }

      let range_start = 0;
      let range_end = 500000;
      let max_buffer = 100000;

      var acresLogScale = d3.scaleLog()
        .domain([ranges.incident_acres_burned[0], ranges.incident_acres_burned[1] + max_buffer])
        .range([range_start, range_end]);

      $( function() {
        $( "#slider-range" ).slider({
          range: true,
          min: range_start,
          max: range_end,
          values: ranges.incident_acres_burned,
          slide: function( event, ui ) {
            $( "#size" ).val( Math.round(acresLogScale.invert(ui.values[ 0 ])) + " - " + 
                              Math.round(acresLogScale.invert(ui.values[ 1 ] )));
            filterData("incident_acres_burned",
                      [acresLogScale.invert(ui.values[0]), acresLogScale.invert(ui.values[1])]);
          }
        });

        $( "#size" ).val( ranges.incident_acres_burned[0] + 
                          " - " + 
                          (ranges.incident_acres_burned[1] + max_buffer));
      });

      // draw the state
      mapLayer.append("path")
        .attr("class", "state")
        .data([california])
        .attr("d", path);

      drawVis(dataset)
    }

    function drawVis(dataset) { //draw the circiles initially and on each interaction with a control
      // console.log(dataset);
      let map = mapLayer.selectAll("circle")
        .data(dataset, d => d.incident_id); // give it a key
      
      // filter out first
      map.exit().remove();

      map.enter().append("circle")
        .attr("r", 5)
        .attr("fill-opacity", .5)
        .attr("fill", "red")
        .attr("transform", d => "translate(" + projectionWrapper([d.incident_longitude, d.incident_latitude]) + ")");
    }

    function filterData(_attr, values) {
      //update filter data
      filter_query[_attr] = values;
      // generating query
      let query = []
      for (let attr in filter_query) { // for simpler code, consider using underscore.js or equivalent.
        let r = filter_query[attr];
        if (r.constructor.name === "Array") {
          // how you get datatype
          // for a continous variable (filtered by array)
          query.push({
            key: attr,
            range: r
          })
        } 
      //   else if (r.constructor.name === "String" && !patt.test(r)) {
      //     // for categorical variable, when it is "all", no query is generated
      //     query.push({
      //       key: attr,
      //       value: r
      //     })
      //   }
      }
      let toVisualize = dataset.filter((d, i) => isQueried(d, query));
      drawVis(toVisualize);
    }

    function isQueried(d, query) {
      // if not in a range or not the value, return false; otherwise return true;
      // query could be JSON, but Array tends to be more generic.
      for (let i = 0; i < query.length; i++) {
        let val = d[query[i].key]
        if (query[i].hasOwnProperty("range")) {
          if (query[i].range[0] > val || query[i].range[1] < val) {
            return false;
          }
        } else if (query[i].hasOwnProperty("value")) {
          if (query[i].value !== val) return false;
        }
      }
      return true;
    }

    // function logslider(position) {
    //   // position will be between 0 and 100
    //   var minp = 0;
    //   var maxp = 100;

    //   // The result should be between 100 an 10000000
    //   var minv = Math.log(100);
    //   var maxv = Math.log(10000000);

    //   // calculate adjustment factor
    //   var scale = (maxv-minv) / (maxp-minp);

    //   return Math.exp(minv + scale*(position-minp));
    // }

    
  </script>

  <p>
    <label for="size">Acres burned:</label>
    <input type="text" id="size" readonly style="border:0; color:#f6931f; font-weight:bold;">
  </p>
 
  <div id="slider-range"></div>

</body>
</html>